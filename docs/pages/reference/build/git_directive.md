---
title: Adding source code from git repositories
sidebar: reference
permalink: reference/build/git_directive.html
summary: |
  <a href="https://docs.google.com/drawings/d/e/2PACX-1vSJax_QDnGEkIwiNndib4Yu4sKxX4sMntjb33YfOYXvb3E3wqLRxII09gvNyuxDw5gYoAoLG24gmM_I/pub?w=2031&amp;h=144" data-featherlight="image">
      <img src="https://docs.google.com/drawings/d/e/2PACX-1vSJax_QDnGEkIwiNndib4Yu4sKxX4sMntjb33YfOYXvb3E3wqLRxII09gvNyuxDw5gYoAoLG24gmM_I/pub?w=1016&amp;h=72">
  </a>
      
  <div class="tab">
    <button class="tablinks active" onclick="openTab(event, 'local')">Local</button>
    <button class="tablinks" onclick="openTab(event, 'remote')">Remote</button>
  </div>
  
  <div id="local" class="tabcontent active">
    <div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">git</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">as</span><span class="pi">:</span> <span class="s">&lt;custom name&gt;</span>
    <span class="s">add</span><span class="pi">:</span> <span class="s">&lt;absolute path&gt;</span>
    <span class="s">to</span><span class="pi">:</span> <span class="s">&lt;absolute path&gt;</span>
    <span class="s">owner</span><span class="pi">:</span> <span class="s">&lt;owner&gt;</span>
    <span class="s">group</span><span class="pi">:</span> <span class="s">&lt;group&gt;</span>
    <span class="s">includePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
    <span class="s">excludePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
    <span class="s">stageDependencies</span><span class="pi">:</span>
      <span class="s">install</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
      <span class="s">beforeSetup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
      <span class="s">setup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span></code></pre>
    </div>
  </div>
  
  <div id="remote" class="tabcontent">
    <div class="language-yaml highlighter-rouge"><pre class="highlight"><code><span class="s">git</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">url</span><span class="pi">:</span> <span class="s">&lt;git repo url&gt;</span>
    <span class="s">branch</span><span class="pi">:</span> <span class="s">&lt;branch name&gt;</span>
    <span class="s">commit</span><span class="pi">:</span> <span class="s">&lt;commit&gt;</span>
    <span class="s">tag</span><span class="pi">:</span> <span class="s">&lt;tag&gt;</span>
    <span class="s">as</span><span class="pi">:</span> <span class="s">&lt;custom name&gt;</span>
    <span class="s">add</span><span class="pi">:</span> <span class="s">&lt;absolute path&gt;</span>
    <span class="s">to</span><span class="pi">:</span> <span class="s">&lt;absolute path&gt;</span>
    <span class="s">owner</span><span class="pi">:</span> <span class="s">&lt;owner&gt;</span>
    <span class="s">group</span><span class="pi">:</span> <span class="s">&lt;group&gt;</span>
    <span class="s">includePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
    <span class="s">excludePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
    <span class="s">stageDependencies</span><span class="pi">:</span>
      <span class="s">install</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
      <span class="s">beforeSetup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span>
      <span class="s">setup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;relative path or glob&gt;</span></code></pre>
      </div>
  </div>
---

## What is git-path? 

_Git-путь_ описывает файл или директорию из git-репозитория, которую нужно добавить в образ по определённому пути. Репозиторий может быть локальным, в директории, где расположен dappfile, или удалённым, тогда описание git-пути содержит адрес репозитория и версию в дереве коммитов (ветка, тэг или хэш коммита). 

dapp добавляет файлы в образ из репозитория двумя способами: полным переносом или наложением патчей. Полный перенос обычно происходит не очень часто, а если файлы уже были перенесены, то для сборки следующих коммитов будет использоваться патч. Подробно этот механизм разобран ниже в части More details: archive, g_a_, latest_patch .

Описание git-пути поддерживает фильтрацию файлов и с помощью набора описаний git-путей можно сформировать практически любую итоговую файловую структуру в образе. Также описание git-пути решает проблему владельца файлов, т.к. можно сразу указать владельца и его группу.

git-путь может содержать сабмодули — dapp это обнаруживает и делает всё что можно, чтобы правильно обработать изменения в сабмодулях.

Пример описания для добавления в итоговый образ исходников из /src локального репозитория в директорию /app и исходников phantomjs в директорию /src/phantomjs:

```
dimg: backend-app
git:
- add: /src
  to: /app
- url: https://github.com/ariya/phantomjs
  add: /
  to: /src/phantomjs
```

## Motivation for git-paths

Main idea is to bring git history into build process.

### Patching instead of copying

Большая часть коммитов в репозиторий приложения относится к обновлению кода самого приложения. В этом случае, если не требуется компиляция, сборка нового образа должна представлять собой не более, чем добавление изменений к файлам предыдущего образа.

### Remote repositories

Сборка приложения может зависеть от исходных текстов в других репозиториях. dapp предоставляет возможность добавлять файлы из удалённых репозиториев в итоговый образ, при этом механизм добавления изменений не отличается для локальных и удалённых репозиториев.

## Syntax of a git path

Описание git-пути для локального репозитория имеет следующие параметры:

- add — путь к директории или файлу, содержимое которых нужно скопировать в образ. Путь указывается относительно корня репозитория, но при этом путь абсолютный, т.е. должен начинаться с /. Параметр необязательный, по умолчанию переносится содержимое всего репозитория, т.е. запись add: / эквивалентна отсутствию параметра;
- to — путь в образе, куда будет скопировано то, что указано в add;
- owner — идентификатор или имя пользователя, который будет владельцем скопированных файлов;
- group — идентификатор или имя группы, которая будет владельцем скопированных файлов;
- excludePaths — набор масок для игнорирования файлов или директорий во время рекурсивного копирования. Пути в масках указываются относительно add;
- includePaths — набор масок для включения файлов или директорий во время рекурсивного копирования. Пути указываются относительно add;
- stageDependencies — набор масок, определяющих файлы по пути add, изменение которых приведёт к пересборке пользовательских стадий. Этот механизм рассмотрен подробно в статье  Running assembly instructions.

git-путь для удалённого репозитория имеет дополнительные параметры:
- url — адрес удалённого репозитория;
- branch, tag, commit — имя ветки, тэга или хэш коммита, который будет использоваться. Если эти параметры не указаны, то используется ветка master;
- as — алиас для упрощения получения информации о удалённом репозитории в шаблонах helm. Подробности в статье деплой.

## Uses of git paths

### Простое копирование

Параметр add указывает путь в репозитории, откуда нужно рекурсивно взять все файлы и добавить их по пути to в образе, если параметр не указан, то путь по умолчанию — /, т.е. будет переносится весь репозиторий.
Например:

```
---
dimg: frontend
git:
- add: /
  to: /app
```

Это самый простой вариант git-пути, который добавляет всё содержимое из репозитория в директорию /app в образе.
Если в репозитории такая структура:

image1

То в образе будет такая структура:

image2

Можно указывать несколько git-путей:

```
---
dimg: frontend
git:
- add: /src
  to: /app/src
- add: /assets
  to: /static
```

Если в репозитории такая структура:

image3

То в образе будет такая структура:

image4

Важно понимать, что в директорию образа, указанную в to, из директории репозитория, указанной в add, будет рекурсивно перенесено именно содержимое, а не директория. То есть, если из репозитория нужно перенести директорию /assets в директорию /app/assets, то слово assets придётся написать два раза, либо использовать git-путь с фильтром includePaths.

_Замечание:  В dapp нет соглашения про / на конце, которое есть в rsync, т.е. add: /src и add: /src/ — одно и тоже._



### Копирование файла

Копирование из add содержимого, а не указанной директории работает и для файлов. Чтобы перенести файл в образ, нужно указать его имя дважды — один раз в add, а другой раз в to. Это даёт дополнительную возможность переименовать файл:

```
---
dimg: frontend
git:
- add: /config/prod.yaml
  to: /app/conf/production.yaml
```

### Смена владельца
Для git-пути предусмотрены параметры `owner` и `group` — это имена или числовые id владельца и группы для всех переносимых в образ файлов и директорий. 

```
---
dimg: frontend
from: ubuntu:18.04
git:
- add: /src/index.php
  to: /app/index.php
  owner: www-data
```

image_here

Можно заметить, что при указании только параметра `owner`, группа для файлов будет совпадать с основной группой владельца.

Если указывается строковое имя пользователя или группы, то такой пользователь или группа должны быть в образе к моменту полного добавления файлов, иначе сборка завершится с ошибкой.

```
---
dimg: frontend
from: ubuntu:18.04
git:
- add: /src/index.php
  to: /app/index.php
  owner: wwwdata
```

image_here


### Копирование с фильтрами

При обработке списка файлов учитываются параметры `excludePaths` и `includePaths` — это наборы масок, которыми можно исключить или включить файлы и директории из списка файлов, которые будут перенесены в образ. Механизм фильтров excludePaths упрощённо работает так: к каждому файлу, найденному в add применяются маски. Если хотя бы одна маска совпадает, то файл игнорируется, а если нет совпадающих масок, значит файл можно добавлять в образ. includePaths работает наоборот: если совпадает хотя бы одна маска, то файл будет добавлен в образ.

Пример:

```
dimg: frontend
git:
- add: /src
  to: /app
  includePaths:
  - **/*.php
```

Чтобы определить, совпадает файл с маской или нет, выполняется такой алгоритм:
- путь в add склеивается с маской;
- берётся абсолютный путь к файлу внутри репозитория;
- два пути сравниваются с помощью fnmatch с флагами FNM_PATHNAME и FNM_PERIOD (в шаблон `*` включается `.`, но исключается `/`);
- если fnmatch возвращает true, то маска совпадает, алгоритм завершается;
- путь в add склеивается с маской и с дополнительным шаблоном **/* ;
- берётся абсолютный путь к файлу внутри репозитория;
- два пути сравниваются с помощью fnmatch с флагами FNM_PATHNAME и FNM_DOTMATCH (в шаблон `*` включается `.`, но исключается `/`);
- если fnmatch возвращает true, то маска совпадает, если false, то маска не совпадает;

Замечание: второй шаг с добавлением шаблона **/* сделан для удобства: самый частый случай фильтра — указание рекурсивного копирования директории. С добавлением **/* достаточно указать имя директории и в фильтр попадёт всё её содержимое.

В маске можно указать такие шаблоны:   
- `*` — любые символы, кроме /
-`**` — рекурсивно учитывать все директории
- `?` — один любой символ
- `[a-z]` — один символ из набора
- `{1, 2, 3, abc, foo, bar}` — любой элемент из набора

Примеры фильтров:

```
add: /src
to: /app
includePaths:
- *.php — собрать все php файлы, непосредственно расположенные в /src
- **/*.php — собрать все php файлы рекурсивно из /src (включает маску *.php, т.к. . тоже входит в **)
- module1/**/{config,view,contoller}/*.php — собрать все php файлы рекурсивно из /src/module1, причём только те, которые находятся непосредственно в директориях config, view или controller
- module1 — собрать все файлы рекурсивно из /src/module1 — применение неявного добавления **/*.
```

Одной маской можно собирать исходные тексты по расширению файлов:
```
add: /src
to: /app
includePaths: '**/*.{php,css,js}'
```

С помощью includePaths можно cкопировать один файл:
```
git:
- add: /src
  to: /app
  includePaths: index.php
```
Но конечно переименовать файл в этом случае не получится.

### Внимание: пересечение путей назначения
Если добавляется несколько git-путей, то нужно помнить, что пересечения путей в to могут приводить к невозможности добавления файлов в образ. Например:

```
---
dimg: frontend
git:
- add: /src
  to: /app
- add: /assets
  to: /app
```


dapp при обработке dappfile вычисляет возможные пересечения среди всех git-путей с учётом includePaths и excludePaths. В случае пересечения сборка завершится с ошибкой, но в некоторых случаях dapp не будет ругаться на пересечение, а добавит excludePaths в git-путь. Однако предугадать все возможные случаи невозможно, поэтому, при описании нескольких git-путей желательно не допускать конфликтов пересечения путей.

Пример с автодобавлением exludePaths:

```
dimg: frontend
git:
- add: /src
  to: /app
  excludePaths:  # dapp при обработке этого git-пути будет
  - assets       # работать так, как будто есть этот фильтр
- add: /assets
  to: /app/assets
```

> TODO: Пример с неуловимой ошибкой и пример, как устранить проблему.


## Working with remote repositories

dapp умеет работать с remote репозиториями, как с источниками файлов. Для этого в описании git-пути есть параметр url, где нужно указать адрес репозитория. dapp поддерживает доступ через https и git+ssh.

### https

```
Syntax:
url: https://[USERNAME[:PASSWORD]@]repo_host/repo_path[.git/]
```

https доступ может требовать логин и пароль, например, вот так выглядит адрес в описании сборки в gitlab-ci:

{% raw %}
```
git:
- add: https://{{ env "CI_REGISTRY_USER" }}:{{ env "CI_JOB_TOKEN" }}@registry.gitlab.company.name/common/helper-utils.git
```
{% endraw %}

В этом примере для доступа к переменным окружения на помощь приходит метод env из библиотеки sprig, которая подключена к go-шаблонам dappfile.


### git, ssh

dapp поддерживает доступ к репозиторию через протокол git. Доступ по этому протоколу обычно защищается средствами ssh: так делают github, bitbucket, gitlab, gogs, gitolite… Адрес репозитория в большинстве случаев выглядит так:

```
git:
- add: git@gitlab.company.name:project_group/project.git
```

Для успешной работы с удалёнными репозиториями через ssh важно понять, как dapp ищет ключи доступа.

#### Механизм работы с ключами
Работа с ключами организована через ssh-agent. Ssh-agent это демон, который работает через файловый сокет, путь к которому записывается в переменную среды SSH_AUTH_SOCK. Dapp во все сборочные контейнеры монтирует файловый сокет, и устанавливает переменную окружения SSH_AUTH_SOCK, т.е. подключение к удалённым git-репозиториям устанавливается с ключами, которые зарегистрированы в запущенном ssh-агенте.

Ssh-агент определяется так:
- Если переданы опции --ssh-key (их может быть несколько):
  - Запускается временный ssh-agent с переданными ключами и используется для всех git-операций с удалёнными репозиториями.
  - Если в окружении есть переменная SSH_AUTH_SOCK и запущен агент, то он игнорируется.
- Опций --ssh-key не передано, а агент уже запущен в том окружении, где работает dapp:
  - Будет использована переменная среды SSH_AUTH_SOCK и для git-операций будут использоваться ключи, добавленные в этого агента
- Опций --ssh-key не передано, ssh-агент не запущен:
  - Если существует файл ~/.ssh/id_rsa, то dapp автоматом запускает временный ssh-agent с зарегистрированным ключом из файла ~/.ssh/id_rsa
- Если ничего из предыдущих пунктов не сработало, то ssh-агент не запускается и ключи для работы с git отсутствуют. Сборка с доступом через ssh к удалённому репозиторию завершится с ошибкой.

## More details: archive, git_archive_post_setup_patch, latest_patch
Рассмотрим более детально механизм добавления файлов в итоговый образ. Как известно, docker-образ состоит из нескольких слоёв. Чтобы понять, какие слои будет создавать dapp, рассмотрим действия по сборке на примере 3-ёх последовательных коммитов: 1, 2 и 3:
- Сборка коммита №1. В одном слое добавляются все файлы по описаниям git-путей — это делается с помощью git archive. Это слой стадии git_arсhive.
- Сборка коммита №2. Добавляется ещё один слой, где файлы меняются с помощью наложения патча. Это слой, где накладываются патчи — latest_patch.
- Сборка коммита №3. Изменит только последний слой — слой стадии latest_patch.

Ситуацию со сборками этих коммитов можно представить так:

table 1

| | git_archive | --- | latest_patch |
|---|---|---|---|
| Сделан коммит №1, сборка в 10:00 |  файлы как в коммите №1 | --- | - |
| Сделан коммит №2, сборка в 10:05 |  файлы как в коммите №1 | --- | файлы как в коммите №2 |
| Сделан коммит №3, сборка в 10:15 |  файлы как в коммите №1 | --- | файлы как в коммите №3 |

В этой таблице не зря есть пустое место между слоями. Со временем число коммитов увеличится и патч между коммитом №1 и текущим коммитом может стать довольно большим, что увеличит размер последнего слоя и общий размер образа. Чтобы последний слой не увеличивался со временем, в dapp предусмотрена ещё одна промежуточная стадия —  git_archive_post_setup_patch.
Как dapp работает с тремя стадиями? Теперь для иллюстрации нужно больше коммитов, пусть это будут: 1, 2, 3, 4, 5, 6 и 7.

- Сборка коммита №1. Как и ранее, в одном слое добавляются все файлы по описаниям git-путей — это делается с помощью git archive. Это слой стадии git_arсhive.
- Сборка коммита №2. Добавляется слой стадии git_archive_post_setup_patch, где файлы меняются с помощью наложения патча между 1 и 2.
- Сборка коммита №3.  Добавляется слой стадии latest_patch, где будет применён патч между 2 и 3
- Сборка коммита №4. Размер патча между 1 и 4 не больше 1Mb, поэтому изменяется только слой стадии latest_patch патчем между 2 и 4.
- Сборка коммита №5. Размер патча между 1 и 5 не больше 1Mb, поэтому изменяется только слой стадии latest_patch патчем между 2 и 5.
- Сборка коммита №6. Размер патча между 1 и 6 превышает 1Mb. Теперь изменения применяются в слое стадии git_archive_post_setup_patch.
- Сборка коммита №7. Изменения патчем между 6 и 7 добавляются в слой стадии latest_patch.

То есть, по мере накопления коммитов с момента первой сборки, большие изменения постепенно сбрасываются в слой git_archive_post_setup_patch, а в последний слой попадают относительно небольшие изменения, что сокращает размер кэша и итогового образа.


| | git_archive | git_archive_post_setup_patch | latest_patch |
|---|---:|---:|---:|
| Сделан коммит №1, сборка в 12:00 |  1 |  - | - |
| Сделан коммит №2, сборка в 12:05 |  1 |  2 | - |
| Сделан коммит №3, сборка в 12:15 |  1 |  2 | 3 |
| Сделан коммит №4, сборка в 12:19 |  1 |  2 | 4 |
| Сделан коммит №5, сборка в 12:25 |  1 |  2 | 5 |
| Сделан коммит №6, сборка в 12:45 |  1 | *6 | - |
| Сделан коммит №7, сборка в 12:57 |  1 |  6 | 7 |

\* — патч для коммита R превысил 1Mb и он применяется не в слое стадии latest_patch, а в слое стадии git_archive_post_setup_patch


### Пересборка git_archive
По разным причинам бывает необходимо сбросить слой стадии git_archive, например, накопилось много изменений и пересборка уменьшит размер сборочного кэша и итогового образа. Есть возможность сбросить эту стадию с помощью указания в сообщении коммита строк "[dapp reset]" или "[reset dapp]". Пусть, например, в предыдущей ситуации коммит 4 содержал бы в своём сообщении [dapp reset], тогда сборки выглядели бы так:

| | git_archive | git_archive_post_setup_patch | latest_patch |
|---|---:|---:|---:|
| Сделан коммит №1, сборка в 12:00 |   1 | - | - |
| Сделан коммит №2, сборка в 12:05 |   1 | 2 | - |
| Сделан коммит №3, сборка в 12:15 |   1 | 2 | 3 |
| Сделан коммит №4, сборка в 12:19 |  *4 | - | - |
| Сделан коммит №5, сборка в 12:25 |   4 | 5 | - |
| Сделан коммит №6, сборка в 12:45 |   4 | 5 | 6 |
| Сделан коммит №7, сборка в 12:57 |   4 | 5 | 7 |

\* — коммит 4 содержит в сообщении строку "[dapp reset]", поэтому стадия git_archive пересобирается



### git_archive and rebase
В dapp есть механизм для пересборки стадии git_archive в случае ребейза ветки. Коммит, из которого собирался слой git_archive пропадёт и слой автоматически пересоберётся.
