package docs

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	"mvdan.cc/xurls"

	"github.com/werf/werf/cmd/werf/common"
	"github.com/werf/werf/cmd/werf/common/templates"
)

func printOptions(buf *bytes.Buffer, cmd *cobra.Command) error {
	flags := cmd.NonInheritedFlags()
	flags.SetOutput(buf)
	if flags.HasAvailableFlags() {
		buf.WriteString("{{ header }} Options\n\n```shell\n")
		buf.WriteString(templates.FlagsUsages(flags))
		buf.WriteString("```\n\n")
	}

	parentFlags := cmd.InheritedFlags()
	parentFlags.SetOutput(buf)
	if parentFlags.HasAvailableFlags() {
		buf.WriteString("{{ header }} Options inherited from parent commands\n\n```shell\n")
		buf.WriteString(templates.FlagsUsages(parentFlags))
		buf.WriteString("```\n\n")
	}
	return nil
}

func printEnvironments(buf *bytes.Buffer, cmd *cobra.Command) error {
	environments, ok := cmd.Annotations[common.CmdEnvAnno]
	if !ok {
		return nil
	}

	if environments != "" {
		buf.WriteString("{{ header }} Environments\n\n```shell\n")
		buf.WriteString(environments)
		buf.WriteString("\n```\n\n")
	}

	return nil
}

// GenMarkdownCustom creates custom markdown output.
func GenMarkdownCustom(cmd *cobra.Command, w io.Writer) error {
	buf := new(bytes.Buffer)

	short := cmd.Short
	long := cmd.Long
	if len(long) == 0 {
		long = short
	}

	buf.WriteString(`{% if include.header %}
{% assign header = include.header %}
{% else %}
{% assign header = "###" %}
{% endif %}
`)

	buf.WriteString(replaceLinks(long) + "\n\n")

	if cmd.Runnable() {
		buf.WriteString("{{ header }} Syntax\n\n")
		buf.WriteString(fmt.Sprintf("```shell\n%s\n```\n\n", templates.UsageLine(cmd)))
	}

	if len(cmd.Example) > 0 {
		buf.WriteString("{{ header }} Examples\n\n")
		buf.WriteString(fmt.Sprintf("```shell\n%s\n```\n\n", cmd.Example))
	}

	if err := printEnvironments(buf, cmd); err != nil {
		return err
	}

	if err := printOptions(buf, cmd); err != nil {
		return err
	}

	_, err := buf.WriteTo(w)
	return err
}

func replaceLinks(s string) string {
	links := xurls.Relaxed.FindAllString(s, -1)
	for _, link := range links {
		s = strings.Replace(s, link, fmt.Sprintf("[%[1]s](%[1]s)", link), -1)
	}

	return s
}

func fullCommandFilesystemPath(cmd string) string {
	res := cmd
	res = strings.Replace(res, " ", "_", -1)
	res = strings.Replace(res, "-", "_", -1)
	return res
}

func RegenDocumentationReferenceCli(cmdGroups templates.CommandGroups, rootCmd *cobra.Command) error {
	sidebarPath := "./docs/_data/sidebars/cli.yml"
	baseDir := "./docs/pages/documentation/reference/cli/"

	if err := os.RemoveAll(baseDir); err != nil {
		return fmt.Errorf("unable to remove %s: %s", baseDir, err)
	}
	if err := os.MkdirAll(baseDir, 0777); err != nil {
		return fmt.Errorf("unable to make dir %s: %s", baseDir, err)
	}

	indexPage := `---
title: Command line interface
sidebar: cli
permalink: documentation/reference/cli/index.html
toc: false
---

`

	var processedCommands []string
	var doNewline bool
	for _, group := range cmdGroups {
		if doNewline {
			indexPage += "\n"
		}

		indexPage += fmt.Sprintf("%s:\n", group.Message)
		for _, cmd := range group.Commands {
			fullCommandName := fullCommandFilesystemPath(cmd.CommandPath())
			indexPage += fmt.Sprintf(" - [werf %s]({{ site.baseurl }}/documentation/reference/cli/%s.html) â€” {%% include /documentation/reference/cli/%s.short.md %%}.\n", cmd.Name(), fullCommandName, fullCommandName)
			processedCommands = append(processedCommands, cmd.Name())
		}
		doNewline = true
	}

	path := filepath.Join(baseDir, "index.md")
	if err := ioutil.WriteFile(path, []byte(indexPage), 0644); err != nil {
		return fmt.Errorf("unable to write %s: %s", path, err)
	}

	var allCommands []*cobra.Command
	allCommands = append(allCommands, rootCmd.Commands()...)

	sidebarData := `# This file is generated by "werf docs" command.
# DO NOT EDIT!

entries:
  en:
    f:
      - title: Command line interface
        sf:
          - title: INDEX.HTML
            url: /documentation/reference/cli/index.html
`

	for len(allCommands) > 0 {
		var cmd *cobra.Command
		cmd, allCommands = allCommands[0], allCommands[1:]
		allCommands = append(allCommands, cmd.Commands()...)

		fullCommandName := fullCommandFilesystemPath(cmd.CommandPath())

		cmdPage := fmt.Sprintf(`---
title: %s
sidebar: cli
permalink: documentation/reference/cli/%s.html
---

{%% include /documentation/reference/cli/%s.md %%}
`, cmd.CommandPath(), fullCommandName, fullCommandName)

		path := filepath.Join(baseDir, fmt.Sprintf("%s.md", fullCommandName))
		if err := ioutil.WriteFile(path, []byte(cmdPage), 0644); err != nil {
			return fmt.Errorf("unable to write %s: %s", path, err)
		}

		sidebarData += fmt.Sprintf(`
          - title: %s
            url: /documentation/reference/cli/%s.html
`, cmd.CommandPath(), fullCommandName)
	}

	if err := ioutil.WriteFile(sidebarPath, []byte(sidebarData), 0644); err != nil {
		return fmt.Errorf("unable to write %s: %s", sidebarPath, err)
	}

	return nil
}

func GenCliPartials(cmd *cobra.Command, dir string) error {
	for _, c := range cmd.Commands() {
		if err := GenCliPartials(c, dir); err != nil {
			return err
		}
	}

	if err := writeFullCommandMarkdownPartial(cmd, dir); err != nil {
		return fmt.Errorf("unable to write full command partial: %s", err)
	}

	if err := writeShortCommandMarkdownPartial(cmd, dir); err != nil {
		return fmt.Errorf("unable to write full command partial: %s", err)
	}

	return nil
}

func writeFullCommandMarkdownPartial(cmd *cobra.Command, dir string) error {
	fullCommandName := fullCommandFilesystemPath(cmd.CommandPath())
	basename := fullCommandName + ".md"

	filename := filepath.Join(dir, basename)
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	//if _, err := io.WriteString(f, filename); err != nil {
	//	return err
	//}
	if err := GenMarkdownCustom(cmd, f); err != nil {
		return err
	}
	return nil
}

func writeShortCommandMarkdownPartial(cmd *cobra.Command, dir string) error {
	fullCommandName := fullCommandFilesystemPath(cmd.CommandPath())
	basename := fullCommandName + ".short.md"
	path := filepath.Join(dir, basename)

	var desc string
	if len(cmd.Short) > 0 {
		desc = strings.ToLower(cmd.Short[0:1])
		desc += cmd.Short[1:]
	}

	if err := ioutil.WriteFile(path, []byte(desc), 0644); err != nil {
		return fmt.Errorf("unable to write %s: %s", path, err)
	}

	return nil
}
